串行GC
单线程进行垃圾回收，同时发生GC时需要暂停（stop the world），垃圾回收占用的时间较长，导致系统吞吐量下降。

并行GC
JDK8默认回收机制，多线程进行垃圾回收，效率高于串行GC，但线程之间的上下文切换以及资源竞争也会消耗一部分性能。

CMS GC
主要针对老年代的垃圾进行回收
阶段1：Initial Mark 初始标记
阶段2：Concurrent Mark 并发标记
阶段3：Concurrent PreClean 并发预清理
阶段4：Final Remark 最终标记
阶段5：Concurrent Sweep 并发清理
阶段6：Concurrent Reset 并发重置

优点：
垃圾回收线程可以和用户线程同时执行，不用暂停

缺点：
1.回收时间长，吞吐量不如并行GC（一部分cpu资源让给用户线程使用）
2.使用标记清除算法，会产生大量的空间碎片

G1 GC
CMS垃圾回收器的进阶版，主要有以下执行阶段：
阶段1.初始标记；
标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，需停顿线程，但是耗时很短。
阶段2.并发标记；
从GC Root开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，可与用户程序并发执行。
阶段3.最终标记；
修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，这一阶段需要停顿线程，也可并行执行。
阶段4.筛选回收
首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

需要注意的是，要防止G1 GC退化为串行GC。
